// package main
//
// import (
// 	"chess/game"
// 	"encoding/json"
// 	"fmt"
// 	"io"
// 	"os"
// 	"strconv"
// 	"strings"
// )
//
// type testCase struct {
// 	Depth int    `json:"depth"`
// 	Nodes int    `json:"nodes"`
// 	Fen   string `json:"fen"`
// }
//
// func readTestCases() []testCase {
// 	file, err := os.Open("perft_positions.json")
// 	defer file.Close()
//
// 	if err != nil {
// 		panic(err.Error())
// 	}
//
// 	jsonVals, err := io.ReadAll(file)
//
// 	if err != nil {
// 		panic(err.Error())
// 	}
//
// 	testCases := make([]testCase, 0)
//
// 	err = json.Unmarshal(jsonVals, &testCases)
//
// 	if err != nil {
// 		panic(err.Error())
// 	}
//
// 	return testCases
// }
//
// func test(num int) {
// 	testCases := readTestCases()
// 	if num == -1 {
// 		for _, tc := range testCases {
// 			val, err := game.NumNodes(tc.Fen, tc.Depth)
//
// 			if err != nil {
// 				panic(err.Error())
// 			}
//
// 			if tc.Nodes != val {
// 				fmt.Printf("Expected: %v, Got: %v\n", tc.Nodes, val)
// 			} else {
// 				fmt.Printf("TRUE\n")
// 			}
//
// 		}
// 	} else {
// 		tc := testCases[num]
//
// 		val, err := game.NumNodes(tc.Fen, tc.Depth)
//
// 		if err != nil {
// 			panic(err.Error())
// 		}
//
// 		fmt.Printf("Expected: %v, Got: %v\n", tc.Nodes, val)
//
// 	}
// }
//
// func strToSq(a string) game.Square {
// 	x := a[0] - 'a'
// 	y := 7 - (a[1] - '1')
//
// 	return game.Square{Y: int(y), X: int(x)}
// }
// func strToMv(a string) game.Move {
// 	m := game.Move{
// 		From: strToSq(a[0:2]),
// 		To:   strToSq(a[2:]),
// 	}
//
// 	if len(a) == 5 {
// 		prm := game.PieceType(strings.ToUpper(string(a[4])))
// 		m.Promotion = &prm
// 	}
// 	return m
// }
//
// func SqToStr(s game.Square) string {
// 	letter := string(byte('a' + s.X))
// 	number := strconv.Itoa(7 - s.Y + 1)
//
// 	return letter + number
// }
//
// func MvToStr(m game.Move) string {
// 	str := SqToStr(m.From) + SqToStr(m.To)
//
// 	if m.Promotion != nil {
// 		str += string(*m.Promotion)
// 	}
//
// 	return str
// }
//
// func tester(fen string, depth int) {
// 	moves := []string{"a1a8", "b7a8", "e1d1"}
//
// 	g, err := game.ParseFEN(fen)
// 	if err != nil {
// 		panic(err.Error())
// 	}
//
// 	for _, m := range moves {
// 		err := game.ApplyMove(g, strToMv(m))
// 		if err != nil {
// 			panic(err.Error())
// 		}
// 	}
//
// 	fen = g.ToFen()
//
// 	nodes, err := game.NumNodes(fen, depth-len(moves))
//
// 	if err != nil {
// 		panic(err.Error())
// 	}
//
// 	fmt.Printf("nodes: %v\n", nodes)
//
// 	mvs := g.LegalMoves()
//
// 	for _, m := range mvs {
// 		gC := g.Copy()
// 		err := game.ApplyMove(&gC, m)
// 		if err != nil {
// 			panic(err.Error())
// 		}
//
// 		nodes, err := game.NumNodes(gC.ToFen(), depth-len(moves)-1)
//
// 		fmt.Printf("%v: %v\n", MvToStr(m), nodes)
// 	}
//
// 	fmt.Println(g.ToFen())
// }
//
// func main() {
// 	test(-1)
// }
